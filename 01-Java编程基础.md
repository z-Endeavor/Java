# Java编程基础



## Java基础

### 注释

- 单行注释：注释一行文字（// 注释）
- 多行注释：注释一段文字（/* 注释 */）
- 文档注释：JavaDoc，可以配合参数使用功能 （/** 注释 */）



### 标识符

Java的所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。

Java定义了如下**关键字**：

| abstract       | assert           | boolean       | break          | byte       |
| -------------- | ---------------- | ------------- | -------------- | ---------- |
| **case**       | **catch**        | **char**      | **class**      | **const**  |
| **continue**   | **default**      | **do**        | **double**     | **else**   |
| **enum**       | **extends**      | **final**     | **finally**    | **float**  |
| **for**        | **goto**         | **if**        | **implements** | **import** |
| **instanceof** | **int**          | **interface** | **long**       | **native** |
| **new**        | **package**      | **private**   | **protected**  | **public** |
| **return**     | **strictfp**     | **short**     | **static**     | **super**  |
| **switch**     | **synchronized** | **this**      | **throw**      | **throws** |
| **transient**  | **try**          | **void**      | **volatile**   | **while**  |

- 所有的标识符都应该以字母（A-Z或者a-z）美元符（$）、或者下划线（_）开始
- 首字符之后可以是字母（A-Z或者a-z），美元符（$）、下划线（_）或数字的任何字符组合
- **不能使用关键字作为变量名或方法名**
- Java是一种强类型语言，标识符是**大小写敏感**的
- 不建议用中文和拼音

> 强类型语言：要求变量的使用要严格符合规定，所有变量都必须先定义后使用。



### 数据类型

- **基本类型（primitive type）**
  - 数值类型
    - 整数类型
      - byte：1个字节，-128-127
      - short：2个字节，-32768-32767
      - int：4个字节，-2147483648-2147483647
      - long：8个字节，-9223372036854775808-9223372036854775807
    - 浮点类型
      - float：4个字节
      - double：8个字节
    - 字符类型
      - char：2个字节
  - boolean类型：占1位，true/false

> Long类型一般要在数字后面加个L，如 `long num = 18L;`
>
> float类型一般要在数字后面加个F，如`float num = 52.1F;`

- **引用类型（reference type）**
  - 类
  - 接口
  - 数组

#### ☆ 拓展问题：

**1、整数类型** —— 进制问题

​	二进制 - 0b、十进制、八进制 - 0、十六进制 - 0x

**2、浮点类型** —— 精度丢失

​	<u>最好完全避免使用浮点数进行比较</u>。（可以用BigDecimal数学工具类）

**3、字符类型** —— 编码和转义

​	Unicode编码（2字节）：0 - 65536。所有的字符本质还是数字。

​	转义字符：\t - 制表符、\n - 换行 ……



### 类型转换

由于Java是强类型语言，所以在进行有些运算的时候，需要用到类型转换。

不同类型的数据先转换为同一类型，然后进行运算。

```java
低 —————————————————————————————————————————————>高

byte, short, char -> int -> long -> float -> double
```

- 强制类型转换：**高->低**，（类型）变量名
- 自动类型转换：**低->高**

> 1. 不能对布尔值进行转换
>
> 2. 不能把对象类型转换成不相干的类型
> 3. 在把高容量转换到低容量的时候，强制转换
> 4. 转换过程可能存在**内存溢出**，或者**精度问题**

#### ☆ 拓展问题：

**1、溢出问题**

​	操作大数时，要注意数据类型的范围，防止溢出。

> JDK7新特性，数字之间可以用下划线分割。如：int n = 20_0000_0000



### 变量

Java是一种强类型语言，每个变量都必须声明其类型。

Java变量是程序中最基本的存储单元，其要素包括<u>变量名</u>，<u>变量类型</u>和<u>作用域</u>。

> 1. 每个变量都有类型，类型可以是基本类型，也可以是引用类型。
> 2. 变量名必须是合法的标识符。
> 3. 变量声明是一条完整的语句，因此每一个声明都必须以分号结束。

#### 变量作用域

1. 类变量：static关键字，从属于<u>类</u>。
2. 实例变量：类内，从属于<u>对象</u>。如果不自行初始化，则为这个类型的默认值。
   - 数值类型的默认值为0。
   - 布尔值的默认值为false。
   - 除了基本类型之外，其余类型默认值为null。
3. 局部变量：方法或语句块内。使用前必须声明和初始化值。

#### 常量

特殊的变量，初始化后在程序运行过程中<u>不能再改变值</u>，不会变动的值。

常量名一般使用**大写字符**。

使用**final**关键词定义。

#### 变量的命令规范

- 所有变量、方法、类名：见名知意。
- 类成员变量：首字母小写和驼峰原则（mouthSalary）
- 局部变量：首字母小写和驼峰原则
- 常量：大写字母和下划线
- 类名：首字母大写和驼峰原则
- 方法名：首字母小写和驼峰原则



### 运算符

- **算术运算符**：+、-、*、/、%、++、--
- **赋值运算符**：=
- **关系运算符**：>、<、>=、<=、==、!=、instanceof
- **逻辑运算符**：&&、||、！
- 位运算符：&、|、^、~、>>、<<、>>>
- 条件运算符：？：
- 扩展赋值运算符：+=、-+、*=、/=

> 如果有long类型在其中运算，则结果类型为long类型。没有long类型时，所有非int类型转为int类型。

#### 自增自减运算符（++、--）

一元运算符。

b = a++：先给b赋值，再自增。

b = ++a：先自增，再给b赋值。

#### 幂运算

使用Math数学工具类。如Math.pow（2,3）即为2^3。

#### 逻辑运算符

&&与运算：有假为假

> 短路运算：若a为假，则a&&b运算不执行b。如int a = 4; boolean b = (a<3)&&(a++<3);，则**a++不执行，a的值还为4**。

||或运算：有真为真

！非运算：假为真，真为假

异或运算：同号为假，异号为真

#### 位运算

与逻辑运算类似。**效率极高**！

左移运算<<：相当于*2。

右移运算>>：相当于/2。

#### ☆ 拓展问题：

**1、字符串连接符 +**

​	若输出前面有字符串类型，则后面变量均转换成字符串类型。

```java
int a = 10;
int b = 20;
System.out.println(""+a+b); //输出为1020
System.out.println(a+b+""); //输出为30
```

**2、运算符优先级**



### 包机制

为了更好地组织类，Java提供了包机制，用于区别类名的命名空间。

包的本质就是“文件夹”。

```java
// 包的语法格式
package pkg1[.pkg2[.pkg3...]];
```

一般用**公司域名倒置**作为包名。

```java
// 导入其他包 (*代表导入所有类)
import package1[.package2...].(classname|*);
```



### JavaDoc

javadoc命令用来生成自己的API文档。

参数信息：

- @author 作者名 
- @version 版本号
- @since 指明需要最早使用的jdk版本
- @param 参数名
- @return 返回值情况
- @throws 异常抛出情况



## Java流程控制

### 用户交互Scanner

Scanner类可以来<u>获取用户的输入</u>。

```java
// 创建一个扫描器对象，用于接收键盘数据
Scanner scanner = new Scanner(System.in);
// 判断用户有没有输入字符串，使用hasNext()和hasNextLine()判断是否还有输入的数据
if (scanner.hasNextLine()) {
    // 使用next()和nextLine()获取输入的字符串
    String str = scanner.nextLine();
}

// 属于IO流的类如果不关闭会一直占用资源，最好用完就关闭
scanner.close();
```

> next()和nextLine()的区别：
>
> **next():**
>
> 		1. 一定要读取到有效字符后才可以结束输入。
> 		2. 对输入有效字符之前遇到的空白，next()方法会自动将其去掉。
> 		3. 只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。
> 		4. next()<u>不能得到带有空格的字符串</u>。
>
> **nextLine():**
>
> 	1. <u>以Enter为结束符</u>，返回的是输入回车之前的所有字符。
> 	2. 可以获得空白。



### 顺序结构

Java的基本结构就是顺序结构，顺序结构是最简单的算法结构。



### 选择结构

- if单选择结构

  ```java
  if (布尔表达式) {
  	// 如果布尔表达式为true将执行的语句
  }
  ```

- if双选择结构

  ```java
  if (布尔表达式) {
  	// 如果布尔表达式为true
  } else {
      // 如果布尔表达式为false
  }
  ```

- if多选择结构

  ```java
  if (布尔表达式1) {
  	// 如果布尔表达式1为true
  } else if (布尔表达式2) {
      // 如果布尔表达式2为true
  } else if (布尔表达式3) {
      // 如果布尔表达式3为true
  } else {
      // 如果以上布尔表达式都不为true
  }
  ```

- 嵌套的if结构

  ```java
  if (布尔表达式1) {
  	// 如果布尔表达式1为true
      if (布尔表达式2) {
      	// 如果布尔表达式2为true
  	}
  }
  ```

- switch多选择结构

  判断一个变量与一系列值中的某个值是否相等，每个值称为一个分支。
  
  ```java
  switch(expression) {
      case value:
          // 语句
          break; // 可选
      case value:
          // 语句
          break; //可选
      // 可以有任意数量的case语句
      default: // 可选
          // 语句
  }
  ```
  
  

### 循环结构

- while循环


最基本的循环。

```java
while ( 布尔表达式 ) {
	// 循环内容
}
```

- do...while 循环

对于while循环，如果不满足条件，则不能进入循环。do...while循环至少会执行一次。

```java
do {
	// 循环内容
} while( 布尔表达式 )
```

- for循环

支持迭代的通用结构，是**最有效、最灵活**的循环结构。循环次数在执行前就确定。

```java
for (初始化; 布尔表达式; 更新) {
    // 代码内容
}
```

> 最先执行初始化步骤，可以声明一种类型，但可初始化一个或多个循环控制变量，<u>也可以是空语句</u>。
>
> 然后检测布尔表达式的值，如果为true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。
>
> 在册检测布尔表达式。循环执行上面的过程。

- 增强for循环

**遍历数组的元素**。

```java
for( 声明语句: 表达式) {
	// 代码句子
}
```

声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域<u>限定在循环语句块</u>，其值与此时数组元素的值相等。

表达式：表达式是要访问的<u>数组</u>名，或者<u>返回值为数组的方法</u>。



### break continue

break在任何循环语句的主体部分，均可用break控制循环的流程。break用于强行退出循环，不执行循环中剩余的语句（break语句也在switch语句中使用）。

continue语句用在循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。

goto关键字：<u>带标签</u>的break和continue。

> “标签”：后面跟一个冒号的标识符，如label:。



## Java方法

Java方法是**语句的集合**，它们在一起执行一个功能。类似于其它的语言的函数，是一段用来完成特定功能的代码片段。

- 方法是解决一类问题的步骤的有序组合
- 方法包含于类或对象中
- 方法在程序中被创建，在其他地方被引用

> 设计方法的原则：方法的本意是功能块，就是实现某个功能的语句块的集合。最好保持方法的原子性，就是**一个方法只完成一个功能**，这样有利于后期的扩展。



### 方法定义

定义一个方法包含一个方法头和一个方法体：

```java
修饰符 返回值类型 方法 (参数类型 参数名) {
    ...
	方法体
    ...
    return 返回值;
}
```

**修饰符**：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。

**返回值类型：**方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType是关键字void,

**方法名**：是方法的实际名称。方法名和参数表共同构成方法签名。

**参数类型**：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。

- 形式参数：在方法被调用时用于接收外界输入的数据。
- 实参：调用方法时实际传给方法的数据。

**方法体**：方法体包含具体的语句，定义该方法的功能。



### 方法调用

调用方法：对象名.方法名（实参列表）

Java有两种方法调用的方式，根据方法是否有返回值来选择。

- 当方法返回一个值的时候，方法调用通常被当做一个值。

```java
int large = max(30,40);
```

- 如果方法的返回值是void，方法调用一定是一条语句。

```java
System.out.println("Hello");
```

> 静态方法：和类一起加载。
>
> 非静态方法：类实例化之后才存在。



### 方法重载

在一个类中，有相同的函数名称，但形参不同的函数。

方法重载的规则：

- 方法名称必须相同
- **参数列表必须不同**（个数不同、类型不同、参数排列顺序不同等）
- 方法的返回类型可以相同也可以不同
- 仅仅通过返回类型不同不足以成为方法的重载



### 命令行传参

运行程序的时候传递消息，需要靠<u>传递命令行参数给main()函数</u>实现。



### 可变参数（不定项参数）

在方法声明中，在指定参数类型后加一个省略号（...）

一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。

```java
public void test(int... i){
	System.out.println(i[0]);
}
```



### 递归

自己调用自己。利用递归可以用简单的程序来解决复杂的问题。

通常把一个大型复杂问题层层转化为一个**与原问题相似的规模较小**的问题来求解。

递归的能力在于用有限的语句来定义对象的无限集合。

递归结构包括两个部分：

- 递归头：什么时候不调用自身方法。如果没有头，将陷入死循环。
- 递归体：什么时候需要调用自身方法。



#### ☆ 拓展问题：

**1、值传递 和 引用传递**



## Java数组

数组是相同类型数据的有序集合。

描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成。

每一个数据称为一个数组元素，每个数组元素可以通过一个下标来访问。



### 数组声明创建

必须声明数组变量，才能在程序中使用数组。

```java
dataType[] arrayRefVar; //首选方法
dataType arrayRefVar[]; //效果相同，但不首选
```

Java里使用**new操作符**来创建数组。

```java
dataType[] arrayRefVar = new dataType[arraySize];
```

数组的元素是通过**索引**访问的，数组索引从0开始。

获取数组长度： arrays.length。



### *Java内存分析

**堆**

- 存放new的对象和数组
- 可以被所有的线程共享，不会存放别的对象引用

**栈**

- 存放基本变量类型（会包含这个基本类型的具体数值）
- 引用对象的变量（会存放这个引用在堆里面的具体地址）

**方法区**

- 可以被所有线程共享
- 包含了所有class和static变量



### 初始化

- 静态初始化：创建+赋值

```java
int[] a = {1,2,3};
Man[] mans = {new Man(1,2), new Man(2,3)};
```

- 动态初始化：包含默认初始化

```java
int[] a = new int[2];
a[0] = 1;
a[1] = 2;
```

- 默认初始化

​	数组是引用类型，它的元素相当于类的实例变量，因此一经分配空间，其中每个元素也被按照实例变量同样的方式被隐式初始化。



> 数组的基本特点：
>
> - **长度确定**。一旦被创建，大小不可改变。
> - 元素必须是相同类型，不允许出现混合类型。
> - 数组元素可以是任何数据类型，包括**基本类型**和**引用类型**。
> - 数组变量属于引用类型，数组也可以看成对象，数组中的每个元素相当于该对象的成员变量。**所以数组对象本身是在堆中的。**



### 数组使用

- For-Each循环
- 数组作方法入参
- 数组作返回值



### 二维数组

多维数组可以看作<u>数组的数组</u>，比如二维数组就是一个特殊的一维数组，每一个元素都是一个一维数组。



### Arrays类

数组的工具类java.util.Arrays。Arrays类中的方法都是static静态方法，在使用的时候可以使用类名直接调用，而不用使用对象来调用。

具有以下常用功能：（可以查看JDK帮助文档）

- 给数组赋值：通过fill方法。
- 对数组排序：通过sort方法，按升序。
- 比较数组：通过equals方法比较数组中元素值是否相等。
- 查找数组元素：通过binarySearch方法能对排序好的数组进行二分查找操作。



## 面向对象

Java的**核心思想就是OOP**（面向对象编程，Object-Oriented Programming）。

物以类聚，**分类**的思维模式，思考问题首先会解决问题需要那些分类，然后对这些分类进行单独思考。最后才对某个分类下的细节进行面向过程的思索。

面向对象适合处理复杂的问题，适合处理需要多人协作的问题。

面向对象编程的本质：**以类的方式组织代码，以对象的形式组织（封装）数据。**

面向对象的核心思想——**抽象**。

三大特性：**封装、继承、多态**

> **类与对象的关系**：
>
> 从认识论角度考虑是先有对象后又类。对象，是具体的事物。类，是抽象的，是对对象的抽象。
>
> 从代码运行角度考虑是先有类后有对象。类是对象的模板。
>
> 类是一种**抽象**的数据类型，它是对某一类事物整体描述/定义，但是并不能代表某一个具体的事物。
>
> 对象是抽象概念的**具体实例**。



### 对象创建与初始化

使用**new关键字**创建对象。除了分配内存空间之外，还会给创建好的对象进行<u>默认的初始化</u>以及<u>对类中构造器的调用</u>。

类中的**构造器**也成为了构造方法，是在创造对象的过程中必须要调用的。

> 构造器：
>
> 1. 和类名相同
> 2. 没有返回值
>
> 作用：new 的本质就是调用构造方法；初始化对象的值。
>
> 注意：定义有参构造器后，如果想使用无参构造器，需要显式地定义一个无参的构造器。



### 封装

“<u>高内聚，低耦合</u>”。类的内部数据操作细节自己完成，不允许外部干涉；仅暴露少量的方法给外部使用。

**属性私有**（private）；**get/set**（public的操作属性的方法）

> 封装的意义：
>
> 1. 提供程序的安全性，保护数据
> 2. 隐藏代码的实现细节
> 3. 统一接口
> 4. 增加系统可维护性



### 继承

继承的本质是对某一批类的抽象。**子类是父类的扩展**。

Java中类只有单继承，没有多继承。

在Java中所有的类都默认继承Object类。



### super

1. super 是调用父类的构造方法，必须在构造方法的第一个。
2. super 必须只能出现在子类的方法或者构造方法中。
3. super 和 this 不能同时调用构造方法。

**Vs this：**

- 代表的对象不同：
  - this： 本身调用者这个对象
  - super：代表父类对象的应用
- 前提
  - this：没有继承也可以使用
  - super：只能在继承条件才可以使用
- 构造方法
  - this()：本类的构造
  - super()：父类的构造



### 重写

需要有继承关系，子类重写父类的方法。重写都是**方法**的重写，与属性无关。

1. 方法名必须相同
2. 参数列表必须相同
3. 修饰符：范围可以扩大但不能缩小    public>protected>default>private
4. 抛出的异常：范围可以被缩小但不能扩大

> 无法被重写：
>
> 1. static 方法，属于类，它不属于实例
> 2. final 常量
> 3. private 方法



### 多态

动态编译：类型可扩展性。多态是**方法**的多态，与属性无关。

同一个方法可以根据发送对象的不同而采用多种不同的行为方式。

一个对象的<u>实际类型是确定的</u>，但是可以指向对象的<u>引用类型有很多</u>（父类，或有关系的类）。

**存在条件**：

1. 有继承关系
2. 子类重写父类方法
3. 父类引用指向子类对象



### 类型转换

**instanceof** ：判断一个对象是什么类型。

1. 父类引用指向子类的对象
2. 把子类转换为父类，向上转型
3. 把父类转换为子类，向下转型：需要强制转换
4. 方便方法的调用，减少重复的代码



### 抽象类

abstract修饰符可以用来修饰方法（**抽象方法**）也可以用来修饰类（抽象类）。

<u>抽象类中可以没有抽象方法，但是有抽象方法的类一定要声明为抽象类。</u>

注意：

1. 抽象类不能用 new 来创建对象，只能靠子类来实现它。抽象类就是一种**约束**。
2. 抽象方法，只有方法的声明，没有方法的实现，它是用来让子类实现的。

> 抽象类有构造方法。



### 接口（interface）

接口就是规范，定义的是一组规范。

接口中的所有方法定义都是抽象的（**public abstract**），所有属性定义都是常量（public static final）

实现了接口的类，就需要<u>重写接口中的方法</u>。

可以利用接口实现**多继承**。

接口不能被实例化，接口中没有构造方法。



### N种内部类

内部类就是在一个类的内部再定义一个类。

1. 成员内部类
2. 静态内部类
3. 匿名内部类
4. 局部内部类



## 异常

异常指程序运行中出现的意外状况：文件找不到、网络连接失败、非法参数等。

异常发生在程序运行期间，影响了正常的程序执行流程。

- 检查性异常：用户错误或问题引起的异常，程序员无法预见。
- 运行时异常：被程序员避免的异常。
- 错误：脱离程序员控制的问题。

Java把异常当做对象来处理，定义一个基类java.lang.Throwable作为所有异常的超类。异常类分为**Error**和**Exception**两大类。



### Error

Error类对象由Java虚拟机（JVM）生成并抛出，通常是致命错误，是程序无法控制和处理的，Java虚拟机（JVM）一般会选择终止线程。



### Exception

通常是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。

Exception分支中有一个重要子类RuntimeException（运行时异常）

- ArrayIndexOutOfBoundsException（数组下标越界）
- NullPointerException（空指针异常）
- ArithmeticException（算术异常）
- MissingResourceException（丢失资源）
- ClassNotFoundException（找不到类）等异常

这些异常不是检查异常，程序中可以选择捕获处理，也可以不处理。

这些异常一般是由**程序逻辑错误**引起，程序员应该从逻辑角度尽可能避免这类异常的发生。（程序员自己的问题）



### 异常处理机制

**抛出异常**和**捕获异常**。

五个关键字：try、catch、finally、throw、throws。

```java
try{ //try监控区域
    // 语句块
}catch(0){  //catch(想要捕获的异常类型) 捕获异常
    
}catch(){   //假设要捕获多个异常 从小到大！
    // ...
}finally{  // 处理善后工作
    // 语句块
}
```

**throw：**主动地抛出异常，一般在**方法中**使用。

**throws：**假设方法中处理不了，在**方法上**向外抛出异常。

> - 在多重catch块后面，可以加一个catch（Exception）来处理可能会被遗漏的异常
> - 对于不确定的代码，可以加一个try-catch，处理潜在的异常。
> - 尽量去处理异常，切忌只是简单的调用printStackTrace（）去打印输出。
> - 尽量添加finally（）语句来释放占用的资源。



### 自定义异常

除了Java内置的异常类，用户可以自定义异常。用户自定义的异常类，只需继承Exception类即可。

步骤：

1. 创建自定义异常类。
2. 在方法中通过throw抛出异常对象。
3. 如果在当前抛出异常的方法中处理异常，可以用try-catch语句捕获并处理；否则在方法的声明处通过throws关键字致命要抛出给方法调用者的异常，继续进行下一步操作。
4. 在出现异常方法的调用者中捕获并处理异常。







